# Entry #2 - Functional and Imperative Programming

Before taking this class, I had only heard of Haskell through a friend who happened to also be a computer science student. I didn't know what Haskell was, but I had heard of it. As computer science students, many of us are accustomed to hearing about C++, C#, Python, Java, etc. However, upon entering this class I didn't know what a functional vs. imperative programming language was and what the differences were between the two. 

## Functional and Imperative Programming
According to [The Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/linq/functional-vs-imperative-programming#:~:text=With%20an%20imperative%20approach%2C%20a,of%20functions%20to%20be%20executed.) functional programming... 
> "was explicitly created to support a pure functional approach to problem solving. Functional programming is a form of declarative programming... a functional approach involves composing the problem as a set of functions to be executed. You define carefully the input to each function, and what each function returns."  
>

While with imperative programming "a developer writes code that specifies the steps that the computer must take to accomplish the goal."


## Example of Imperative Programming (via [Stack Overflow](https://stackoverflow.com/questions/17826380/what-is-difference-between-functional-and-imperative-programming-languages))

Take Java as an example of an imperative programming language. We see the sequence of steps taken to complete a goal mentioned above when trying to add a sum of numbers: 

<pre><code>int total = 0;
 int num1 = 5;
 int num2 = 10;
 int num3 = 15;
 total = num1 + num2 + num3; 
</code></pre>

On the otherhand, with functional programming, the order of execution (of steps in a program) is of low importance. There is also no state changes and the language is declarative. With declarative programming, we decide declare) the rules we are going to follow. 

## Benefits of Functional Programming
Functional programming is beneficial as it is for the most part more straight-forward than imperative programming. With lessened complexities such as not having states, functional programming is great for upscaling. Pure functions are also more readily testable as they can easily be tested individually, also allowing for easier debugging. 


